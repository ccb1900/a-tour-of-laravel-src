# 设计模式
### 代理
### 外观
# 例子
代理
```
namespace App\Facades;


use Illuminate\Support\Facades\Facade;

class Demo extends Facade
{
    public static function getFacadeAccessor()
    {
        return "demo"; // TODO: Change the autogenerated stub
    }
}
```
被代理的类
```
namespace App\Facades;


class DemoClass
{
    public function test()
    {
        print_r("test");
    }
}
```
此处的demo和第一段代码返回的demo是同一个。
```
$this->app->bind("demo",function (){
      return new DemoClass();
});
```
注册别名
```
'Demo' => \App\Facades\Demo::class
```
使用
```
Artisan::command('test:facade', function () {
    \App\Facades\Demo::test();//
    \Demo::test();//需要经过容器解析到\App\Facades\Demo
})->describe('Display an inspiring quote');
```
# 源码实现
- 对象依赖容器解析
- 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。
- 以Demo为例
- Demo Facades调用test方法时，由于方法不存在，就会调用Facade 的__callStatic方法
- 已经解析的会从$resolvedInstance直接获取，没有解析的会获取容器绑定并注册到$resolvedInstance
- getFacadeAccessor可以返回对象，但是不会被注册到$resolvedInstance。这是因为$resolvedInstance的元素都是不可变的。
- 调用实例的test方法
# 简单实现
https://git.itiswho.com/ccb/a-tour-of-laravel-src/src/master/examples/facade.php


